package charts

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"path/filepath"
	"strings"

	"github.com/blang/semver"
	"github.com/go-git/go-billy/v5"
	"github.com/rancher/charts-build-scripts/pkg/filesystem"
	"github.com/rancher/charts-build-scripts/pkg/helm"
	"github.com/rancher/charts-build-scripts/pkg/icons"
	"github.com/rancher/charts-build-scripts/pkg/logger"
	"github.com/rancher/charts-build-scripts/pkg/path"
	helmLoader "helm.sh/helm/v3/pkg/chart/loader"
	"helm.sh/helm/v3/pkg/chartutil"
)

// Package represents the configuration of a particular forked Helm chart
type Package struct {
	Chart `yaml:",inline"`

	// Name is the name of the package
	Name string `yaml:"name"`
	// Version represents the version of the package. It will override other values if it exists
	Version *semver.Version `yaml:"version,omitempty"`
	// PackageVersion represents the current version of the package. It needs to be incremented whenever there are changes
	PackageVersion *int `yaml:"packageVersion"`
	// AdditionalCharts are other charts that should be packaged together with this
	AdditionalCharts []*AdditionalChart `yaml:"additionalCharts,omitempty"`
	// DoNotRelease represents a boolean flag that indicates a package should not be tracked in make charts
	DoNotRelease bool `yaml:"doNotRelease,omitempty"`
	// Auto triggers the auto chart bump
	Auto bool `yaml:"auto,omitempty"`
	// AutoGeneratedBumpVersion is the version that the package should be bumped to
	// If present, this will override all other versions
	AutoGeneratedBumpVersion *semver.Version

	// fs is a filesystem rooted at the package
	fs billy.Filesystem
	// rootFs is a filesystem rooted at the repository containing the package
	rootFs billy.Filesystem
}

// Prepare pulls in a package based on the spec to the local git repository
func (p *Package) Prepare(ctx context.Context) error {
	logger.Log(ctx, slog.LevelInfo, "make prepare")

	if err := p.Chart.Prepare(ctx, p.rootFs, p.fs); err != nil {
		logger.Log(ctx, slog.LevelError, "encountered error while preparing chart", slog.String("path", p.Chart.WorkingDir), logger.Err(err))
		return err
	}

	if p.Chart.Upstream.IsWithinPackage() {
		// in the case of local chart
		for _, additionalChart := range p.AdditionalCharts {
			exists, err := filesystem.PathExists(ctx, p.fs, additionalChart.WorkingDir)
			if err != nil {
				return fmt.Errorf("encountered error while trying to check if %s exists: %s", additionalChart.WorkingDir, err)
			}
			if !exists {
				continue
			}
			// Local charts need to revert changes before trying to prepare additional charts
			if err := additionalChart.RevertMainChanges(ctx, p.fs); err != nil {
				return fmt.Errorf("encountered error while reverting changes from %s to main chart: %s", additionalChart.WorkingDir, err)
			}
		}
	}
	logger.Log(ctx, slog.LevelInfo, "preparing additional charts")
	for _, additionalChart := range p.AdditionalCharts {
		if err := additionalChart.Prepare(ctx, p.rootFs, p.fs, p.Chart.UpstreamChartVersion); err != nil {
			return fmt.Errorf("encountered error while preparing additional chart %s: %s", additionalChart.WorkingDir, err)
		}
		if err := additionalChart.ApplyMainChanges(ctx, p.fs); err != nil {
			return fmt.Errorf("encountered error while applying main changes from %s to main chart: %s", additionalChart.WorkingDir, err)
		}
	}
	return nil
}

// GeneratePatch generates a patch on a forked Helm chart based on local changes
func (p *Package) GeneratePatch(ctx context.Context) error {
	logger.Log(ctx, slog.LevelInfo, "make patch")

	for _, additionalChart := range p.AdditionalCharts {
		if err := additionalChart.RevertMainChanges(ctx, p.fs); err != nil {
			return fmt.Errorf("encountered error while reverting changes from %s to main chart: %s", additionalChart.WorkingDir, err)
		}
	}

	if err := p.Chart.GeneratePatch(ctx, p.rootFs, p.fs); err != nil {
		return fmt.Errorf("encountered error while generating patch on main chart: %s", err)
	}

	for _, additionalChart := range p.AdditionalCharts {
		if err := additionalChart.ApplyMainChanges(ctx, p.fs); err != nil {
			return fmt.Errorf("encountered error while applying main changes from %s to main chart: %s", additionalChart.WorkingDir, err)
		}
		if err := additionalChart.GeneratePatch(ctx, p.rootFs, p.fs); err != nil {
			return fmt.Errorf("encountered error while generating patch on additional chart %s: %s", additionalChart.WorkingDir, err)
		}
	}

	return nil
}

// DownloadIcon Downloads the icon from the charts.yaml file to the assets/logos folder
// and changes the chart.yaml file to use it
func (p *Package) DownloadIcon(ctx context.Context) error {
	logger.Log(ctx, slog.LevelInfo, "make icon")

	exists, err := filesystem.PathExists(ctx, p.fs, path.RepositoryChartsDir)
	if err != nil {
		return fmt.Errorf("failed to check for charts dir. Err: %w", err)
	}
	if !exists {
		logger.Log(ctx, slog.LevelError, "charts dir does not exist, run make prepare first", slog.String("path", path.RepositoryChartsDir))
		return nil
	}

	absHelmChartPath := filesystem.GetAbsPath(p.fs, path.RepositoryChartsDir)
	chart, err := helmLoader.Load(absHelmChartPath)
	if err != nil {
		return fmt.Errorf("could not load Helm chart: %s", err)
	}

	if !strings.HasPrefix(chart.Metadata.Icon, "file://") {
		logger.Log(ctx, slog.LevelDebug, "chart icon is pointing to a remote url", slog.String("url", chart.Metadata.Icon))

		// download icon and change the icon property to point to it
		p, err := icons.Download(ctx, p.rootFs, chart.Metadata)
		if err == nil { // managed to download the icon and save it locally
			chart.Metadata.Icon = fmt.Sprintf("file://%s", p)
		} else {
			logger.Log(ctx, slog.LevelError, "failed to download icon", logger.Err(err))
		}

		chartYamlPath := fmt.Sprintf("%s/Chart.yaml", absHelmChartPath)
		err = chartutil.SaveChartfile(chartYamlPath, chart.Metadata)
		if err != nil {
			return fmt.Errorf("failed to save chart.yaml file. err: %w", err)
		}
	}

	exist, err := filesystem.PathExists(ctx, p.rootFs, strings.TrimPrefix(chart.Metadata.Icon, "file://"))
	if err != nil {
		return err
	}

	if !exist {
		return errors.New("icon path is a file:// prefix, but the icon does not exist, you will need to manually download it at assets/logos dir")
	}

	return nil
}

// GenerateCharts creates Helm chart archives for each chart after preparing it
func (p *Package) GenerateCharts(ctx context.Context, omitBuildMetadataOnExport bool) error {
	logger.Log(ctx, slog.LevelInfo, "make charts")

	if p.DoNotRelease {
		logger.Log(ctx, slog.LevelInfo, "skipping package marked doNotRelease")
		return nil
	}
	if err := p.Prepare(ctx); err != nil {
		return fmt.Errorf("encountered error while trying to prepare package: %s", err)
	}

	// Add PackageVersion to format
	err := p.Chart.GenerateChart(ctx, p.rootFs, p.fs, p.PackageVersion, p.Version, p.AutoGeneratedBumpVersion, omitBuildMetadataOnExport)
	if err != nil {
		return fmt.Errorf("encountered error while exporting main chart: %s", err)
	}

	for _, additionalChart := range p.AdditionalCharts {
		err = additionalChart.GenerateChart(ctx, p.rootFs, p.fs, p.PackageVersion, p.Version, p.AutoGeneratedBumpVersion, omitBuildMetadataOnExport)
		if err != nil {
			return fmt.Errorf("encountered error while exporting %s: %s", additionalChart.WorkingDir, err)
		}
	}

	if err := helm.CreateOrUpdateHelmIndex(ctx, p.rootFs); err != nil {
		return err
	}
	return p.Clean(ctx)
}

// Clean removes all other files except for the package.yaml, patch, and overlay/ files from a package
func (p *Package) Clean(ctx context.Context) error {
	logger.Log(ctx, slog.LevelInfo, "make clean")

	chartPathsToClean := []string{p.Chart.OriginalDir()}
	if !p.Chart.Upstream.IsWithinPackage() {
		chartPathsToClean = append(chartPathsToClean, p.Chart.WorkingDir)
	} else {
		// Local charts should clean up added dependencies
		chartPathsToClean = append(chartPathsToClean, filepath.Join(p.Chart.WorkingDir, "charts"))
	}
	for _, additionalChart := range p.AdditionalCharts {
		if additionalChart.Upstream != nil && (*additionalChart.Upstream).IsWithinPackage() {
			// Working directory never needs to be clean for an additional chart
			continue
		}
		exists, err := filesystem.PathExists(ctx, p.fs, additionalChart.WorkingDir)
		if err != nil {
			return fmt.Errorf("encountered error while trying to check if %s exists: %s", additionalChart.WorkingDir, err)
		}
		if exists {
			if err := additionalChart.RevertMainChanges(ctx, p.fs); err != nil {
				return fmt.Errorf("encountered error while reverting changes from %s to main chart: %s", additionalChart.WorkingDir, err)
			}
		}
		chartPathsToClean = append(chartPathsToClean, additionalChart.OriginalDir(), additionalChart.WorkingDir)
	}
	for _, chartPath := range chartPathsToClean {
		if err := filesystem.RemoveAll(p.fs, chartPath); err != nil {
			return fmt.Errorf("encountered error while trying to remove %s from package %s: %s", chartPath, p.Name, err)
		}
	}
	return nil
}
